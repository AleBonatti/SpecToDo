# BucketBits — Image Fetching Architecture
### *AI-Driven Media Suggestions with Tool-Based Image Enrichment*

## Overview
This document describes the new architecture for handling image fetching in BucketBits using the Vercel AI SDK tool system.  
The goal is to **avoid unreliable URLs generated by the model** and replace them with **verified images fetched by authoritative external APIs**, based on the semantic category defined for each item.

## 1. Category “type” Field

A new `type` column will be added to the **category** table in Supabase.

- Type: `text`
- Purpose: defines which external API/tool should be used for media enrichment.
- Examples:
  - `"cinema"`
  - `"music"`
  - `"book"`
  - `"place"`
  - `"generic"`

This column must be editable in the **Category Edit Form** inside the application.

## 2. Tool-Based Image Fetching

A set of AI tools will be defined, each responsible for fetching images from a specific external provider:

- `searchMovieTool` → TMDB (The Movie Database)
- `searchMusicTool` → Spotify / iTunes
- `searchPlaceTool` → Google Places / Yelp
- `searchGenericTool` → Unsplash / fallback

Each tool:

- Accepts parameters (e.g., `searchQuery`, optional metadata such as `year`)
- Calls a predefined external API
- Returns metadata + a trusted `imageUrl` (or `null`)

## 3. AI Behavior Based on Category Type

When generating suggestions, the AI will:

1. Read the **type** value from the category.
2. Choose the **appropriate tool**:
   - type = `"cinema"` → use `searchMovieTool`
   - type = `"music"` → use `searchMusicTool`
   - type = `"place"` → use `searchPlaceTool`
   - fallback → use `searchGenericTool`
3. Produce structured results and then enrich them via tool calls.

This ensures that:

- Movies → get posters from TMDB  
- Music → get album covers  
- Books → get book covers  
- Places → get photos  
- Generic → a default strategy is used  

## 4. Expanded Base Search Result Structure

Each suggestion returned by the model must include extra fields (depending on type):

### Common Fields
```json
{
  "title": "string",
  "type": "cinema | music | place | generic | ...",
  "description": "string | null",
  "year": 1994,
  "creator": "Quentin Tarantino",
  "searchQuery": "Pulp Fiction 1994 movie Quentin Tarantino"
}
```

### Field Requirements

- **title**  
  The identified media title or entity name.

- **type**  
  Mirrors the category type.

- **description**  
  Optional short summary (if known).

- **year**  
  Required for cinema/music/book when available. Optional for other categories.

- **creator**  
  Director, author, or artist (if available).

- **searchQuery**  
  A **structured string** specifically designed to work with external APIs.  
  If missing or empty → **skip the API call**.

## 5. Handling `searchQuery`

- If `searchQuery` is **valid**, the API tool is invoked.
- If `searchQuery` is **empty, invalid, or unreliable**, the system:
  - skips the tool call,
  - returns a **placeholder image**.

This avoids wasting requests and prevents broken images.

## 6. Image URL Verification

After a tool returns an `imageUrl`:

1. Perform a `HEAD` or lightweight `GET` request.
2. Check HTTP status:
   - If `200` → the image is valid.
   - If `404` or any `>= 400` code → discard image and return placeholder.

### Resulting rule:
> *No invalid or broken external images will ever be displayed to the user.*

## 7. First Implementation: `searchMovieTool`

For now, only the **movie tool** is required:

### `searchMovieTool`
- Input params:
  - `query` (movie title + metadata)
  - `year` (optional)
- Calls TMDB Search API
- Extracts:
  - poster path (if any)
  - overview
  - release year
- Formats:
  ```json
  {
    "found": true,
    "title": "Pulp Fiction",
    "year": 1994,
    "overview": "...",
    "imageUrl": "https://image.tmdb.org/t/p/w500/...jpg"
  }
  ```
- Verifies image URL before returning.

Additional tools (`searchMusicTool`, `searchPlaceTool`, etc.) will be implemented later following the same pattern.

## 8. Summary of the Whole Flow

1. User saves an item in BucketBits.
2. Item belongs to a category → category has a `type`.
3. AI generates suggestions (title, description, year, creator, searchQuery, ...).
4. AI decides which **tool** to call based on the `type`.
5. The selected tool queries an external trusted API.
6. Backend validates the returned image URL.
7. If valid → returned to the UI.  
   If not valid → fallback placeholder.
8. Client displays the enriched suggestion cleanly.
